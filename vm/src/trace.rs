//! Nexus VM program traces
//!
//! A trace is generated by running a Nexus VM program.
//! A `Trace` holds a number of `Blocks`, and each `Block` holds
//! a number of `Steps`. The number of steps in each block
//! (also referred to as `k`), corresponds to the instructions
//! per folding step. Thus, each block corresponds to one
//! folding step.
//!
//! A `Trace` can be divided at block boundaries and each subtrace
//! proved independently of the others (when using PCD). Each `Block`
//! contains enough information to reconstruct the `Witness` for each
//! step contained in the block. The witnesses can be reconstructed
//! by iterating over the steps in the block.

use crate::error::Result;
use crate::eval::{eval_inst, NexusVM, Regs};
use crate::memory::Memory;
use crate::rv32::{parse::*, RV32::UNIMP};

use serde::{Deserialize, Serialize};

/// Represents a program trace.
#[derive(Default, Clone, Serialize, Deserialize)]
pub struct Trace {
    /// Steps per fold/block.
    pub k: usize,
    /// First block in this (sub)trace.
    pub start: usize,
    /// The blocks contained in this trace.
    pub blocks: Vec<Block>,
}

/// A seqeunce of program steps.
#[derive(Default, Clone, Serialize, Deserialize)]
pub struct Block {
    /// Starting register file for this block.
    pub regs: Regs,
    /// Sequence of `k` steps contained in this block.
    pub steps: Vec<Step>,
}

/// A program step.
#[derive(Default, Clone, Serialize, Deserialize)]
pub struct Step {
    /// Encoded NexusVM instruction.
    pub inst: u32,
    /// Result of instruction evaluation.
    pub Z: u32,
    /// Next program counter, for jump and branch instructions.
    pub PC: Option<u32>,
}

impl Trace {
    /// Split a trace into subtraces with `n` blocks each. Note, the
    /// final subtrace may contain fewer than `n` blocks.
    pub fn split_by(&self, n: usize) -> impl Iterator<Item = Self> + '_ {
        let mut index = 0;
        self.blocks.chunks(n).map(move |bs| {
            let start = index;
            index += n;
            Trace {
                k: self.k,
                start,
                blocks: bs.to_vec(),
            }
        })
    }

    /// Return block with index `n`, if it is contained in this (sub)trace.
    pub fn block(&self, n: usize) -> Option<&Block> {
        if self.start > n || self.start + self.blocks.len() <= n {
            return None;
        }
        Some(&self.blocks[n - self.start])
    }

    /// Create a subtrace containing only block `n`.
    pub fn get(&self, n: usize) -> Option<Self> {
        Some(Trace {
            k: self.k,
            start: n,
            blocks: vec![self.block(n)?.clone()],
        })
    }

    /// Estimate the size, in bytes, of this trace.
    pub fn estimate_size(&self) -> usize {
        use std::mem::size_of_val as sizeof;
        sizeof(self)
            + self.blocks.len()
                * (sizeof(&self.blocks[0])
                    + self.blocks[0].steps.len() * sizeof(&self.blocks[0].steps[0]))
    }
}

// Generate a `Step` by evaluating the next instruction of `vm`.
fn step<M: Memory>(vm: &mut NexusVM<M>) -> Result<Step> {
    let pc = vm.regs.pc;
    eval_inst(vm)?;
    let step = Step {
        inst: vm.inst.word,
        Z: vm.Z,
        PC: if vm.regs.pc == pc + 4 {
            None
        } else {
            Some(vm.regs.pc)
        },
    };
    Ok(step)
}

// Generate a `Block` by evaluating `k` steps of `vm`.
fn k_step<M: Memory>(vm: &mut NexusVM<M>, k: usize) -> Result<Block> {
    let mut block = Block {
        regs: vm.regs.clone(),
        steps: Vec::new(),
    };

    for _ in 0..k {
        block.steps.push(step(vm)?);
    }

    Ok(block)
}

/// Generate a program trace by evaluating `vm`, using `k` steps
/// per block. If `pow` is true, the number of blocks will be
/// rounded up to the nearest power of two by inserting UNIMP
/// instructions.
pub fn trace<M: Memory>(vm: &mut NexusVM<M>, k: usize, pow: bool) -> Result<Trace> {
    let mut trace = Trace {
        k,
        start: 0,
        blocks: Vec::new(),
    };

    loop {
        let block = k_step(vm, k)?;
        trace.blocks.push(block);

        if vm.inst.inst == UNIMP {
            if pow {
                let count = trace.blocks.len();
                if count.next_power_of_two() == count + 1 {
                    break;
                }
            } else {
                break;
            }
        }
    }
    Ok(trace)
}

/// Witness for a single VM step.
#[derive(Default, Debug)]
pub struct Witness {
    /// Initial register file.
    pub regs: Regs,
    /// Instruction being executed.
    pub inst: u32,
    /// RISC-V instruction components.
    pub J: u32,
    pub shamt: u32,
    pub rs1: u32,
    pub rs2: u32,
    pub rd: u32,
    pub I: u32,
    /// First argument value.
    pub X: u32,
    /// Second argument value.
    pub Y: u32,
    /// Result of instuction.
    pub Z: u32,
    /// Program counter.
    pub PC: u32,
}

impl Block {
    pub fn iter(&self) -> BlockIter<'_> {
        BlockIter::new(self)
    }
}

impl<'a> IntoIterator for &'a Block {
    type Item = Witness;
    type IntoIter = BlockIter<'a>;

    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}

pub struct BlockIter<'a> {
    regs: Regs,
    block: &'a Block,
    index: usize,
}

impl BlockIter<'_> {
    fn new(b: &Block) -> BlockIter<'_> {
        BlockIter {
            regs: b.regs.clone(),
            block: b,
            index: 0,
        }
    }
}

impl Iterator for BlockIter<'_> {
    type Item = Witness;

    fn next(&mut self) -> Option<Self::Item> {
        if self.index >= self.block.steps.len() {
            return None;
        }

        let s = &self.block.steps[self.index];
        let inst = parse_u32(s.inst).unwrap();
        let mut w = parse_alt(&self.regs, s.inst);
        w.regs = self.regs.clone();
        w.inst = s.inst;
        w.J = inst.index_j();
        w.X = w.regs.x[w.rs1 as usize];
        w.Y = w.regs.x[w.rs2 as usize];
        w.Z = s.Z;
        w.PC = if let Some(pc) = s.PC {
            pc
        } else {
            self.regs.pc + 4
        };

        self.regs.pc = w.PC;
        if w.rd > 0 {
            self.regs.x[w.rd as usize] = w.Z;
        }
        self.index += 1;
        Some(w)
    }
}

fn parse_alt(regs: &Regs, word: u32) -> Witness {
    let mut w = Witness::default();

    match opcode(word) {
        OPC_LUI => {
            w.rd = rd(word);
            w.I = immU(word);
        }
        OPC_AUIPC => {
            w.rd = rd(word);
            w.I = immU(word);
        }
        OPC_JAL => {
            w.rd = rd(word);
            w.I = immJ(word);
        }
        OPC_JALR => {
            w.rd = rd(word);
            w.rs1 = rs1(word);
            w.I = immI(word);
        }
        OPC_BR => {
            w.rs1 = rs1(word);
            w.rs2 = rs2(word);
            w.I = immB(word);
        }
        OPC_LOAD => {
            w.rd = rd(word);
            w.rs1 = rs1(word);
            w.I = immI(word);
        }
        OPC_STORE => {
            w.rs1 = rs1(word);
            w.rs2 = rs2(word);
            w.I = immS(word);
        }
        OPC_ALUI => {
            w.rd = rd(word);
            w.rs1 = rs1(word);
            w.I = immA(word);
            w.shamt = w.I & 0x1f;
        }
        OPC_ALU => {
            w.rd = rd(word);
            w.rs1 = rs1(word);
            w.rs2 = rs2(word);
            w.shamt = regs.x[w.rs2 as usize] & 0x1f;
        }
        OPC_ECALL => {
            w.rd = rd(word);
        }
        _ => (),
    };
    w
}
